--- net/minecraft/src/EntityItem.java
+++ net/minecraft/src/EntityItem.java
@@ -119,6 +119,7 @@
 					var1.triggerAchievement(AchievementList.killCow);
 				}
 
+				ModLoader.OnItemPickup(var1, this.item);
 				this.worldObj.playSoundAtEntity(this, "random.pop", 0.2F, ((this.rand.nextFloat() - this.rand.nextFloat()) * 0.7F + 1.0F) * 2.0F);
 				var1.onItemPickup(this, var2);
 				if(this.item.stackSize <= 0) {
--- /dev/null
+++ net/minecraft/src/BaseMod.java
@@ -1,0 +1,63 @@
+package net.minecraft.src;
+
+import java.util.Map;
+import java.util.Random;
+import net.minecraft.client.Minecraft;
+
+public abstract class BaseMod {
+	public int AddFuel(int id) {
+		return 0;
+	}
+
+	public void AddRenderer(Map<Class<? extends Entity>, Render> renderers) {
+	}
+
+	public boolean DispenseEntity(World world, double x, double y, double z, int xVel, int zVel, ItemStack item) {
+		return false;
+	}
+
+	public void GenerateNether(World world, Random random, int chunkX, int chunkZ) {
+	}
+
+	public void GenerateSurface(World world, Random random, int chunkX, int chunkZ) {
+	}
+
+	public void KeyboardEvent(KeyBinding event) {
+	}
+
+	public void ModsLoaded() {
+	}
+
+	public boolean OnTickInGame(Minecraft game) {
+		return false;
+	}
+
+	public boolean OnTickInGUI(Minecraft game, GuiScreen gui) {
+		return false;
+	}
+
+	public void RegisterAnimation(Minecraft game) {
+	}
+
+	public void RenderInvBlock(RenderBlocks renderer, Block block, int metadata, int modelID) {
+	}
+
+	public boolean RenderWorldBlock(RenderBlocks renderer, IBlockAccess world, int x, int y, int z, Block block, int modelID) {
+		return false;
+	}
+
+	public void TakenFromCrafting(EntityPlayer player, ItemStack item) {
+	}
+
+	public void TakenFromFurnace(EntityPlayer player, ItemStack item) {
+	}
+
+	public void OnItemPickup(EntityPlayer player, ItemStack item) {
+	}
+
+	public String toString() {
+		return this.getClass().getName() + " " + this.Version();
+	}
+
+	public abstract String Version();
+}
--- net/minecraft/src/RenderBlocks.java
+++ net/minecraft/src/RenderBlocks.java
@@ -92,7 +92,7 @@
 	public boolean renderBlockByRenderType(Block var1, int var2, int var3, int var4) {
 		int var5 = var1.getRenderType();
 		var1.setBlockBoundsBasedOnState(this.blockAccess, var2, var3, var4);
-		return var5 == 0 ? this.renderStandardBlock(var1, var2, var3, var4) : (var5 == 4 ? this.renderBlockFluids(var1, var2, var3, var4) : (var5 == 13 ? this.renderBlockCactus(var1, var2, var3, var4) : (var5 == 1 ? this.renderBlockReed(var1, var2, var3, var4) : (var5 == 6 ? this.renderBlockCrops(var1, var2, var3, var4) : (var5 == 2 ? this.renderBlockTorch(var1, var2, var3, var4) : (var5 == 3 ? this.renderBlockFire(var1, var2, var3, var4) : (var5 == 5 ? this.renderBlockRedstoneWire(var1, var2, var3, var4) : (var5 == 8 ? this.renderBlockLadder(var1, var2, var3, var4) : (var5 == 7 ? this.renderBlockDoor(var1, var2, var3, var4) : (var5 == 9 ? this.renderBlockMinecartTrack((BlockRail)var1, var2, var3, var4) : (var5 == 10 ? this.renderBlockStairs(var1, var2, var3, var4) : (var5 == 11 ? this.renderBlockFence(var1, var2, var3, var4) : (var5 == 12 ? this.renderBlockLever(var1, var2, var3, var4) : (var5 == 14 ? this.renderBlockBed(var1, var2, var3, var4) : (var5 == 15 ? this.renderBlockRepeater(var1, var2, var3, var4) : (var5 == 16 ? this.func_31074_b(var1, var2, var3, var4, false) : (var5 == 17 ? this.func_31080_c(var1, var2, var3, var4, true) : false)))))))))))))))));
+		return var5 == 0 ? this.renderStandardBlock(var1, var2, var3, var4) : (var5 == 4 ? this.renderBlockFluids(var1, var2, var3, var4) : (var5 == 13 ? this.renderBlockCactus(var1, var2, var3, var4) : (var5 == 1 ? this.renderBlockReed(var1, var2, var3, var4) : (var5 == 6 ? this.renderBlockCrops(var1, var2, var3, var4) : (var5 == 2 ? this.renderBlockTorch(var1, var2, var3, var4) : (var5 == 3 ? this.renderBlockFire(var1, var2, var3, var4) : (var5 == 5 ? this.renderBlockRedstoneWire(var1, var2, var3, var4) : (var5 == 8 ? this.renderBlockLadder(var1, var2, var3, var4) : (var5 == 7 ? this.renderBlockDoor(var1, var2, var3, var4) : (var5 == 9 ? this.renderBlockMinecartTrack((BlockRail)var1, var2, var3, var4) : (var5 == 10 ? this.renderBlockStairs(var1, var2, var3, var4) : (var5 == 11 ? this.renderBlockFence(var1, var2, var3, var4) : (var5 == 12 ? this.renderBlockLever(var1, var2, var3, var4) : (var5 == 14 ? this.renderBlockBed(var1, var2, var3, var4) : (var5 == 15 ? this.renderBlockRepeater(var1, var2, var3, var4) : (var5 == 16 ? this.func_31074_b(var1, var2, var3, var4, false) : (var5 == 17 ? this.func_31080_c(var1, var2, var3, var4, true) : ModLoader.RenderWorldBlock(this, this.blockAccess, var2, var3, var4, var1, var5))))))))))))))))));
 	}
 
 	private boolean renderBlockBed(Block var1, int var2, int var3, int var4) {
@@ -3332,6 +3332,8 @@
 					}
 
 					var1.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+				} else {
+					ModLoader.RenderInvBlock(this, var1, var2, var5);
 				}
 			}
 		} else {
@@ -3371,6 +3373,6 @@
 	}
 
 	public static boolean renderItemIn3d(int var0) {
-		return var0 == 0 ? true : (var0 == 13 ? true : (var0 == 10 ? true : (var0 == 11 ? true : var0 == 16)));
+		return var0 == 0 ? true : (var0 == 13 ? true : (var0 == 10 ? true : (var0 == 11 ? true : ModLoader.RenderBlockIsItemFull3D(var0))));
 	}
 }
--- net/minecraft/src/ChunkProvider.java
+++ net/minecraft/src/ChunkProvider.java
@@ -121,6 +121,7 @@
 			var4.isTerrainPopulated = true;
 			if(this.chunkProvider != null) {
 				this.chunkProvider.populate(var1, var2, var3);
+				ModLoader.PopulateChunk(this.chunkProvider, var2, var3, this.field_28066_g);
 				var4.setChunkModified();
 			}
 		}
--- net/minecraft/src/RenderManager.java
+++ net/minecraft/src/RenderManager.java
@@ -52,6 +52,7 @@
 		this.entityRenderMap.put(EntityBoat.class, new RenderBoat());
 		this.entityRenderMap.put(EntityFish.class, new RenderFish());
 		this.entityRenderMap.put(EntityLightningBolt.class, new RenderLightningBolt());
+		ModLoader.AddAllRenderers(this.entityRenderMap);
 		Iterator var1 = this.entityRenderMap.values().iterator();
 
 		while(var1.hasNext()) {
--- /dev/null
+++ net/minecraft/src/EntityRendererProxy.java
@@ -1,0 +1,17 @@
+package net.minecraft.src;
+
+import net.minecraft.client.Minecraft;
+
+public class EntityRendererProxy extends EntityRenderer {
+	private Minecraft game;
+
+	public EntityRendererProxy(Minecraft minecraft) {
+		super(minecraft);
+		this.game = minecraft;
+	}
+
+	public void updateCameraAndRender(float f1) {
+		super.updateCameraAndRender(f1);
+		ModLoader.OnTick(this.game);
+	}
+}
--- net/minecraft/src/TileEntityFurnace.java
+++ net/minecraft/src/TileEntityFurnace.java
@@ -177,7 +177,7 @@
 			return 0;
 		} else {
 			int var2 = var1.getItem().shiftedIndex;
-			return var2 < 256 && Block.blocksList[var2].blockMaterial == Material.wood ? 300 : (var2 == Item.stick.shiftedIndex ? 100 : (var2 == Item.coal.shiftedIndex ? 1600 : (var2 == Item.bucketLava.shiftedIndex ? 20000 : (var2 == Block.sapling.blockID ? 100 : 0))));
+			return var2 < 256 && Block.blocksList[var2].blockMaterial == Material.wood ? 300 : (var2 == Item.stick.shiftedIndex ? 100 : (var2 == Item.coal.shiftedIndex ? 1600 : (var2 == Item.bucketLava.shiftedIndex ? 20000 : (var2 == Block.sapling.blockID ? 100 : ModLoader.AddAllFuel(var2)))));
 		}
 	}
 
--- net/minecraft/src/SlotFurnace.java
+++ net/minecraft/src/SlotFurnace.java
@@ -22,6 +22,7 @@
 			this.thePlayer.addStat(AchievementList.cookFish, 1);
 		}
 
+		ModLoader.TakenFromFurnace(this.thePlayer, var1);
 		super.onPickupFromSlot(var1);
 	}
 }
--- /dev/null
+++ net/minecraft/src/ModTextureAnimation.java
@@ -1,0 +1,77 @@
+package net.minecraft.src;
+
+import java.awt.Graphics2D;
+import java.awt.image.BufferedImage;
+import java.awt.image.ImageObserver;
+import org.lwjgl.opengl.GL11;
+
+public class ModTextureAnimation extends TextureFX {
+	private final int tickRate;
+	private final byte[][] images;
+	private int index;
+	private int ticks;
+
+	public ModTextureAnimation(int slot, int dst, BufferedImage source, int rate) {
+		this(slot, 1, dst, source, rate);
+	}
+
+	public ModTextureAnimation(int slot, int size, int dst, BufferedImage source, int rate) {
+		super(slot);
+		this.index = 0;
+		this.ticks = 0;
+		this.tileSize = size;
+		this.tileImage = dst;
+		this.tickRate = rate;
+		this.ticks = rate;
+		this.bindImage(ModLoader.getMinecraftInstance().renderEngine);
+		int targetWidth = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH) / 16;
+		int targetHeight = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT) / 16;
+		int width = source.getWidth();
+		int height = source.getHeight();
+		int images = (int)Math.floor((double)(height / width));
+		if(images <= 0) {
+			throw new IllegalArgumentException("source has no complete images");
+		} else {
+			this.images = new byte[images][];
+			if(width != targetWidth) {
+				BufferedImage i = new BufferedImage(targetWidth, targetHeight * images, 6);
+				Graphics2D temp = i.createGraphics();
+				temp.drawImage(source, 0, 0, targetWidth, targetHeight * images, 0, 0, width, height, (ImageObserver)null);
+				temp.dispose();
+				source = i;
+			}
+
+			for(int var18 = 0; var18 < images; ++var18) {
+				int[] var19 = new int[targetWidth * targetHeight];
+				source.getRGB(0, targetHeight * var18, targetWidth, targetHeight, var19, 0, targetWidth);
+				this.images[var18] = new byte[targetWidth * targetHeight * 4];
+
+				for(int j = 0; j < var19.length; ++j) {
+					int a = var19[j] >> 24 & 255;
+					int r = var19[j] >> 16 & 255;
+					int g = var19[j] >> 8 & 255;
+					int b = var19[j] >> 0 & 255;
+					this.images[var18][j * 4 + 0] = (byte)r;
+					this.images[var18][j * 4 + 1] = (byte)g;
+					this.images[var18][j * 4 + 2] = (byte)b;
+					this.images[var18][j * 4 + 3] = (byte)a;
+				}
+			}
+
+		}
+	}
+
+	public void onTick() {
+		if(this.ticks >= this.tickRate) {
+			++this.index;
+			if(this.index >= this.images.length) {
+				this.index = 0;
+			}
+
+			this.imageData = this.images[this.index];
+			this.ticks = 0;
+		}
+
+		++this.ticks;
+	}
+}
--- net/minecraft/src/PanelCrashReport.java
+++ net/minecraft/src/PanelCrashReport.java
@@ -9,6 +9,7 @@
 import java.io.StringWriter;
 import java.text.SimpleDateFormat;
 import java.util.Date;
+import java.util.Iterator;
 import org.lwjgl.Sys;
 import org.lwjgl.opengl.GL11;
 
@@ -39,7 +40,14 @@
 		var5 = var5 + "\n";
 		var5 = var5 + var3;
 		String var6 = "";
-		var6 = var6 + "\n";
+		var6 = var6 + "Mods loaded: " + (ModLoader.getLoadedMods().size() + 1) + "\n";
+		var6 = var6 + "ModLoader Beta 1.7.3" + "\n";
+
+		BaseMod localTextArea;
+		for(Iterator var12 = ModLoader.getLoadedMods().iterator(); var12.hasNext(); var6 = var6 + localTextArea.getClass().getName() + " " + localTextArea.Version() + "\n") {
+			localTextArea = (BaseMod)var12.next();
+		}
+
 		var6 = var6 + "\n";
 		if(var3.contains("Pixel format not accelerated")) {
 			var6 = var6 + "      Bad video card drivers!      \n";
--- net/minecraft/src/BlockDispenser.java
+++ net/minecraft/src/BlockDispenser.java
@@ -97,33 +97,36 @@
 		if(var12 == null) {
 			var1.func_28106_e(1001, var2, var3, var4, 0);
 		} else {
-			if(var12.itemID == Item.arrow.shiftedIndex) {
-				EntityArrow var19 = new EntityArrow(var1, var13, var15, var17);
-				var19.setArrowHeading((double)var9, (double)0.1F, (double)var10, 1.1F, 6.0F);
-				var19.doesArrowBelongToPlayer = true;
-				var1.entityJoinedWorld(var19);
-				var1.func_28106_e(1002, var2, var3, var4, 0);
-			} else if(var12.itemID == Item.egg.shiftedIndex) {
-				EntityEgg var22 = new EntityEgg(var1, var13, var15, var17);
-				var22.setEggHeading((double)var9, (double)0.1F, (double)var10, 1.1F, 6.0F);
-				var1.entityJoinedWorld(var22);
-				var1.func_28106_e(1002, var2, var3, var4, 0);
-			} else if(var12.itemID == Item.snowball.shiftedIndex) {
-				EntitySnowball var23 = new EntitySnowball(var1, var13, var15, var17);
-				var23.setSnowballHeading((double)var9, (double)0.1F, (double)var10, 1.1F, 6.0F);
-				var1.entityJoinedWorld(var23);
-				var1.func_28106_e(1002, var2, var3, var4, 0);
-			} else {
-				EntityItem var24 = new EntityItem(var1, var13, var15 - 0.3D, var17, var12);
-				double var20 = var5.nextDouble() * 0.1D + 0.2D;
-				var24.motionX = (double)var9 * var20;
-				var24.motionY = (double)0.2F;
-				var24.motionZ = (double)var10 * var20;
-				var24.motionX += var5.nextGaussian() * (double)0.0075F * 6.0D;
-				var24.motionY += var5.nextGaussian() * (double)0.0075F * 6.0D;
-				var24.motionZ += var5.nextGaussian() * (double)0.0075F * 6.0D;
-				var1.entityJoinedWorld(var24);
-				var1.func_28106_e(1000, var2, var3, var4, 0);
+			boolean handled = ModLoader.DispenseEntity(var1, var13, var15, var17, var9, var10, var12);
+			if(!handled) {
+				if(var12.itemID == Item.arrow.shiftedIndex) {
+					EntityArrow var19 = new EntityArrow(var1, var13, var15, var17);
+					var19.setArrowHeading((double)var9, (double)0.1F, (double)var10, 1.1F, 6.0F);
+					var19.doesArrowBelongToPlayer = true;
+					var1.entityJoinedWorld(var19);
+					var1.func_28106_e(1002, var2, var3, var4, 0);
+				} else if(var12.itemID == Item.egg.shiftedIndex) {
+					EntityEgg var22 = new EntityEgg(var1, var13, var15, var17);
+					var22.setEggHeading((double)var9, (double)0.1F, (double)var10, 1.1F, 6.0F);
+					var1.entityJoinedWorld(var22);
+					var1.func_28106_e(1002, var2, var3, var4, 0);
+				} else if(var12.itemID == Item.snowball.shiftedIndex) {
+					EntitySnowball var23 = new EntitySnowball(var1, var13, var15, var17);
+					var23.setSnowballHeading((double)var9, (double)0.1F, (double)var10, 1.1F, 6.0F);
+					var1.entityJoinedWorld(var23);
+					var1.func_28106_e(1002, var2, var3, var4, 0);
+				} else {
+					EntityItem var24 = new EntityItem(var1, var13, var15 - 0.3D, var17, var12);
+					double var20 = var5.nextDouble() * 0.1D + 0.2D;
+					var24.motionX = (double)var9 * var20;
+					var24.motionY = (double)0.2F;
+					var24.motionZ = (double)var10 * var20;
+					var24.motionX += var5.nextGaussian() * (double)0.0075F * 6.0D;
+					var24.motionY += var5.nextGaussian() * (double)0.0075F * 6.0D;
+					var24.motionZ += var5.nextGaussian() * (double)0.0075F * 6.0D;
+					var1.entityJoinedWorld(var24);
+					var1.func_28106_e(1000, var2, var3, var4, 0);
+				}
 			}
 
 			var1.func_28106_e(2000, var2, var3, var4, var9 + 1 + (var10 + 1) * 3);
--- /dev/null
+++ net/minecraft/src/ModTextureStatic.java
@@ -1,0 +1,131 @@
+package net.minecraft.src;
+
+import java.awt.Graphics2D;
+import java.awt.image.BufferedImage;
+import java.awt.image.ImageObserver;
+import org.lwjgl.opengl.GL11;
+
+public class ModTextureStatic extends TextureFX {
+	private boolean oldanaglyph;
+	private int[] pixels;
+
+	public ModTextureStatic(int slot, int dst, BufferedImage source) {
+		this(slot, 1, dst, source);
+	}
+
+	public ModTextureStatic(int slot, int size, int dst, BufferedImage source) {
+		super(slot);
+		this.pixels = null;
+		this.tileSize = size;
+		this.tileImage = dst;
+		this.bindImage(ModLoader.getMinecraftInstance().renderEngine);
+		int targetWidth = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH) / 16;
+		int targetHeight = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT) / 16;
+		int width = source.getWidth();
+		int height = source.getHeight();
+		this.pixels = new int[targetWidth * targetHeight];
+		this.imageData = new byte[targetWidth * targetHeight * 4];
+		if(width == height && width == targetWidth) {
+			source.getRGB(0, 0, width, height, this.pixels, 0, width);
+		} else {
+			BufferedImage img = new BufferedImage(targetWidth, targetHeight, 6);
+			Graphics2D gfx = img.createGraphics();
+			gfx.drawImage(source, 0, 0, targetWidth, targetHeight, 0, 0, width, height, (ImageObserver)null);
+			img.getRGB(0, 0, targetWidth, targetHeight, this.pixels, 0, targetWidth);
+			gfx.dispose();
+		}
+
+		this.update();
+	}
+
+	public void update() {
+		for(int i = 0; i < this.pixels.length; ++i) {
+			int a = this.pixels[i] >> 24 & 255;
+			int r = this.pixels[i] >> 16 & 255;
+			int g = this.pixels[i] >> 8 & 255;
+			int b = this.pixels[i] >> 0 & 255;
+			if(this.anaglyphEnabled) {
+				int grey = (r + g + b) / 3;
+				b = grey;
+				g = grey;
+				r = grey;
+			}
+
+			this.imageData[i * 4 + 0] = (byte)r;
+			this.imageData[i * 4 + 1] = (byte)g;
+			this.imageData[i * 4 + 2] = (byte)b;
+			this.imageData[i * 4 + 3] = (byte)a;
+		}
+
+		this.oldanaglyph = this.anaglyphEnabled;
+	}
+
+	public void onTick() {
+		if(this.oldanaglyph != this.anaglyphEnabled) {
+			this.update();
+		}
+
+	}
+
+	public static BufferedImage scale2x(BufferedImage in) {
+		int width = in.getWidth();
+		int height = in.getHeight();
+		BufferedImage out = new BufferedImage(width * 2, height * 2, 2);
+
+		for(int y = 0; y < height; ++y) {
+			for(int x = 0; x < width; ++x) {
+				int E = in.getRGB(x, y);
+				int B;
+				if(y == 0) {
+					B = E;
+				} else {
+					B = in.getRGB(x, y - 1);
+				}
+
+				int D;
+				if(x == 0) {
+					D = E;
+				} else {
+					D = in.getRGB(x - 1, y);
+				}
+
+				int F;
+				if(x >= width - 1) {
+					F = E;
+				} else {
+					F = in.getRGB(x + 1, y);
+				}
+
+				int H;
+				if(y >= height - 1) {
+					H = E;
+				} else {
+					H = in.getRGB(x, y + 1);
+				}
+
+				int E0;
+				int E1;
+				int E2;
+				int E3;
+				if(B != H && D != F) {
+					E0 = D == B ? D : E;
+					E1 = B == F ? F : E;
+					E2 = D == H ? D : E;
+					E3 = H == F ? F : E;
+				} else {
+					E0 = E;
+					E1 = E;
+					E2 = E;
+					E3 = E;
+				}
+
+				out.setRGB(x * 2, y * 2, E0);
+				out.setRGB(x * 2 + 1, y * 2, E1);
+				out.setRGB(x * 2, y * 2 + 1, E2);
+				out.setRGB(x * 2 + 1, y * 2 + 1, E3);
+			}
+		}
+
+		return out;
+	}
+}
--- /dev/null
+++ net/minecraft/src/ModLoader.java
@@ -1,0 +1,1395 @@
+package net.minecraft.src;
+
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.net.URLDecoder;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Random;
+import java.util.Map.Entry;
+import java.util.logging.FileHandler;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.logging.SimpleFormatter;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+import javax.imageio.ImageIO;
+import net.minecraft.client.Minecraft;
+import org.lwjgl.input.Keyboard;
+
+public final class ModLoader {
+	private static final List animList = new LinkedList();
+	private static final Map blockModels = new HashMap();
+	private static final Map blockSpecialInv = new HashMap();
+	private static final File cfgdir = new File(Minecraft.getMinecraftDir(), "/config/");
+	private static final File cfgfile = new File(cfgdir, "ModLoader.cfg");
+	public static Level cfgLoggingLevel = Level.FINER;
+	private static Map classMap = null;
+	private static long clock = 0L;
+	public static final boolean DEBUG = false;
+	private static Field field_animList = null;
+	private static Field field_armorList = null;
+	private static Field field_blockList = null;
+	private static Field field_modifiers = null;
+	private static Field field_TileEntityRenderers = null;
+	private static boolean hasInit = false;
+	private static int highestEntityId = 3000;
+	private static final Map inGameHooks = new HashMap();
+	private static final Map inGUIHooks = new HashMap();
+	private static Minecraft instance = null;
+	private static int itemSpriteIndex = 0;
+	private static int itemSpritesLeft = 0;
+	private static final Map keyList = new HashMap();
+	private static final File logfile = new File(Minecraft.getMinecraftDir(), "ModLoader.txt");
+	private static final Logger logger = Logger.getLogger("ModLoader");
+	private static FileHandler logHandler = null;
+	private static Method method_RegisterEntityID = null;
+	private static Method method_RegisterTileEntity = null;
+	private static final File modDir = new File(Minecraft.getMinecraftDir(), "/mods/");
+	private static final LinkedList modList = new LinkedList();
+	private static int nextBlockModelID = 1000;
+	private static final Map overrides = new HashMap();
+	public static final Properties props = new Properties();
+	private static BiomeGenBase[] standardBiomes;
+	private static int terrainSpriteIndex = 0;
+	private static int terrainSpritesLeft = 0;
+	private static String texPack = null;
+	private static boolean texturesAdded = false;
+	private static final boolean[] usedItemSprites = new boolean[256];
+	private static final boolean[] usedTerrainSprites = new boolean[256];
+	public static final String VERSION = "ModLoader Beta 1.7.3";
+
+	public static void AddAchievementDesc(Achievement achievement, String s, String s1) {
+		try {
+			if(achievement.statName.contains(".")) {
+				String[] nosuchfieldexception = achievement.statName.split("\\.");
+				if(nosuchfieldexception.length == 2) {
+					String s2 = nosuchfieldexception[1];
+					AddLocalization("achievement." + s2, s);
+					AddLocalization("achievement." + s2 + ".desc", s1);
+					setPrivateValue(StatBase.class, achievement, 1, StringTranslate.getInstance().translateKey("achievement." + s2));
+					setPrivateValue(Achievement.class, achievement, 3, StringTranslate.getInstance().translateKey("achievement." + s2 + ".desc"));
+				} else {
+					setPrivateValue(StatBase.class, achievement, 1, s);
+					setPrivateValue(Achievement.class, achievement, 3, s1);
+				}
+			} else {
+				setPrivateValue(StatBase.class, achievement, 1, s);
+				setPrivateValue(Achievement.class, achievement, 3, s1);
+			}
+		} catch (IllegalArgumentException var5) {
+			logger.throwing("ModLoader", "AddAchievementDesc", var5);
+			ThrowException(var5);
+		} catch (SecurityException var6) {
+			logger.throwing("ModLoader", "AddAchievementDesc", var6);
+			ThrowException(var6);
+		} catch (NoSuchFieldException var7) {
+			logger.throwing("ModLoader", "AddAchievementDesc", var7);
+			ThrowException(var7);
+		}
+
+	}
+
+	public static int AddAllFuel(int i) {
+		logger.finest("Finding fuel for " + i);
+		int j = 0;
+
+		for(Iterator iterator = modList.iterator(); iterator.hasNext() && j == 0; j = ((BaseMod)iterator.next()).AddFuel(i)) {
+		}
+
+		if(j != 0) {
+			logger.finest("Returned " + j);
+		}
+
+		return j;
+	}
+
+	public static void AddAllRenderers(Map map) {
+		if(!hasInit) {
+			init();
+			logger.fine("Initialized");
+		}
+
+		Iterator iterator = modList.iterator();
+
+		while(iterator.hasNext()) {
+			BaseMod basemod = (BaseMod)iterator.next();
+			basemod.AddRenderer(map);
+		}
+
+	}
+
+	public static void addAnimation(TextureFX texturefx) {
+		logger.finest("Adding animation " + texturefx.toString());
+		Iterator iterator = animList.iterator();
+
+		while(iterator.hasNext()) {
+			TextureFX texturefx1 = (TextureFX)iterator.next();
+			if(texturefx1.tileImage == texturefx.tileImage && texturefx1.iconIndex == texturefx.iconIndex) {
+				animList.remove(texturefx);
+				break;
+			}
+		}
+
+		animList.add(texturefx);
+	}
+
+	public static int AddArmor(String s) {
+		try {
+			String[] illegalaccessexception = (String[])((String[])field_armorList.get((Object)null));
+			List list = Arrays.asList(illegalaccessexception);
+			ArrayList arraylist = new ArrayList();
+			arraylist.addAll(list);
+			if(!arraylist.contains(s)) {
+				arraylist.add(s);
+			}
+
+			int i = arraylist.indexOf(s);
+			field_armorList.set((Object)null, arraylist.toArray(new String[0]));
+			return i;
+		} catch (IllegalArgumentException var5) {
+			logger.throwing("ModLoader", "AddArmor", var5);
+			ThrowException("An impossible error has occured!", var5);
+		} catch (IllegalAccessException var6) {
+			logger.throwing("ModLoader", "AddArmor", var6);
+			ThrowException("An impossible error has occured!", var6);
+		}
+
+		return -1;
+	}
+
+	public static void AddLocalization(String s, String s1) {
+		Properties properties = null;
+
+		try {
+			properties = (Properties)getPrivateValue(StringTranslate.class, StringTranslate.getInstance(), 1);
+		} catch (SecurityException var4) {
+			logger.throwing("ModLoader", "AddLocalization", var4);
+			ThrowException(var4);
+		} catch (NoSuchFieldException var5) {
+			logger.throwing("ModLoader", "AddLocalization", var5);
+			ThrowException(var5);
+		}
+
+		if(properties != null) {
+			properties.put(s, s1);
+		}
+
+	}
+
+	private static void addMod(ClassLoader classloader, String s) {
+		try {
+			String throwable = s.split("\\.")[0];
+			if(throwable.contains("$")) {
+				return;
+			}
+
+			if(props.containsKey(throwable) && (props.getProperty(throwable).equalsIgnoreCase("no") || props.getProperty(throwable).equalsIgnoreCase("off"))) {
+				return;
+			}
+
+			Package package1 = ModLoader.class.getPackage();
+			if(package1 != null) {
+				throwable = package1.getName() + "." + throwable;
+			}
+
+			Class class1 = classloader.loadClass(throwable);
+			if(!BaseMod.class.isAssignableFrom(class1)) {
+				return;
+			}
+
+			setupProperties(class1);
+			BaseMod basemod = (BaseMod)class1.newInstance();
+			if(basemod != null) {
+				modList.add(basemod);
+				logger.fine("Mod Loaded: \"" + basemod.toString() + "\" from " + s);
+				System.out.println("Mod Loaded: " + basemod.toString());
+			}
+		} catch (Throwable var6) {
+			logger.fine("Failed to load mod from \"" + s + "\"");
+			System.out.println("Failed to load mod from \"" + s + "\"");
+			logger.throwing("ModLoader", "addMod", var6);
+			ThrowException(var6);
+		}
+
+	}
+
+	public static void AddName(Object obj, String s) {
+		String s1 = null;
+		Exception exception13;
+		if(obj instanceof Item) {
+			Item exception1 = (Item)obj;
+			if(exception1.getItemName() != null) {
+				s1 = exception1.getItemName() + ".name";
+			}
+		} else if(obj instanceof Block) {
+			Block exception11 = (Block)obj;
+			if(exception11.getBlockName() != null) {
+				s1 = exception11.getBlockName() + ".name";
+			}
+		} else if(obj instanceof ItemStack) {
+			ItemStack exception12 = (ItemStack)obj;
+			if(exception12.getItemName() != null) {
+				s1 = exception12.getItemName() + ".name";
+			}
+		} else {
+			exception13 = new Exception(obj.getClass().getName() + " cannot have name attached to it!");
+			logger.throwing("ModLoader", "AddName", exception13);
+			ThrowException(exception13);
+		}
+
+		if(s1 != null) {
+			AddLocalization(s1, s);
+		} else {
+			exception13 = new Exception(obj + " is missing name tag!");
+			logger.throwing("ModLoader", "AddName", exception13);
+			ThrowException(exception13);
+		}
+
+	}
+
+	public static int addOverride(String s, String s1) {
+		try {
+			int throwable = getUniqueSpriteIndex(s);
+			addOverride(s, s1, throwable);
+			return throwable;
+		} catch (Throwable var3) {
+			logger.throwing("ModLoader", "addOverride", var3);
+			ThrowException(var3);
+			throw new RuntimeException(var3);
+		}
+	}
+
+	public static void addOverride(String s, String s1, int i) {
+		boolean j = true;
+		boolean k = false;
+		byte j1;
+		int k1;
+		if(s.equals("/terrain.png")) {
+			j1 = 0;
+			k1 = terrainSpritesLeft;
+		} else {
+			if(!s.equals("/gui/items.png")) {
+				return;
+			}
+
+			j1 = 1;
+			k1 = itemSpritesLeft;
+		}
+
+		System.out.println("Overriding " + s + " with " + s1 + " @ " + i + ". " + k1 + " left.");
+		logger.finer("addOverride(" + s + "," + s1 + "," + i + "). " + k1 + " left.");
+		Object obj = (Map)overrides.get(Integer.valueOf(j1));
+		if(obj == null) {
+			obj = new HashMap();
+			overrides.put(Integer.valueOf(j1), obj);
+		}
+
+		((Map)((Map)obj)).put(s1, Integer.valueOf(i));
+	}
+
+	public static void AddRecipe(ItemStack itemstack, Object[] aobj) {
+		CraftingManager.getInstance().addRecipe(itemstack, aobj);
+	}
+
+	public static void AddShapelessRecipe(ItemStack itemstack, Object[] aobj) {
+		CraftingManager.getInstance().addShapelessRecipe(itemstack, aobj);
+	}
+
+	public static void AddSmelting(int i, ItemStack itemstack) {
+		FurnaceRecipes.smelting().addSmelting(i, itemstack);
+	}
+
+	public static void AddSpawn(Class class1, int i, EnumCreatureType enumcreaturetype) {
+		AddSpawn((Class)class1, i, enumcreaturetype, (BiomeGenBase[])null);
+	}
+
+	public static void AddSpawn(Class class1, int i, EnumCreatureType enumcreaturetype, BiomeGenBase[] abiomegenbase) {
+		if(class1 == null) {
+			throw new IllegalArgumentException("entityClass cannot be null");
+		} else if(enumcreaturetype == null) {
+			throw new IllegalArgumentException("spawnList cannot be null");
+		} else {
+			if(abiomegenbase == null) {
+				abiomegenbase = standardBiomes;
+			}
+
+			for(int j = 0; j < abiomegenbase.length; ++j) {
+				List list = abiomegenbase[j].getSpawnableList(enumcreaturetype);
+				if(list != null) {
+					boolean flag = false;
+					Iterator iterator = list.iterator();
+
+					while(iterator.hasNext()) {
+						SpawnListEntry spawnlistentry = (SpawnListEntry)iterator.next();
+						if(spawnlistentry.entityClass == class1) {
+							spawnlistentry.spawnRarityRate = i;
+							flag = true;
+							break;
+						}
+					}
+
+					if(!flag) {
+						list.add(new SpawnListEntry(class1, i));
+					}
+				}
+			}
+
+		}
+	}
+
+	public static void AddSpawn(String s, int i, EnumCreatureType enumcreaturetype) {
+		AddSpawn((String)s, i, enumcreaturetype, (BiomeGenBase[])null);
+	}
+
+	public static void AddSpawn(String s, int i, EnumCreatureType enumcreaturetype, BiomeGenBase[] abiomegenbase) {
+		Class class1 = (Class)classMap.get(s);
+		if(class1 != null && EntityLiving.class.isAssignableFrom(class1)) {
+			AddSpawn(class1, i, enumcreaturetype, abiomegenbase);
+		}
+
+	}
+
+	public static boolean DispenseEntity(World world, double d, double d1, double d2, int i, int j, ItemStack itemstack) {
+		boolean flag = false;
+
+		for(Iterator iterator = modList.iterator(); iterator.hasNext() && !flag; flag = ((BaseMod)iterator.next()).DispenseEntity(world, d, d1, d2, i, j, itemstack)) {
+		}
+
+		return flag;
+	}
+
+	public static List getLoadedMods() {
+		return Collections.unmodifiableList(modList);
+	}
+
+	public static Logger getLogger() {
+		return logger;
+	}
+
+	public static Minecraft getMinecraftInstance() {
+		if(instance == null) {
+			try {
+				ThreadGroup nosuchfieldexception = Thread.currentThread().getThreadGroup();
+				int i = nosuchfieldexception.activeCount();
+				Thread[] athread = new Thread[i];
+				nosuchfieldexception.enumerate(athread);
+
+				for(int j = 0; j < athread.length; ++j) {
+					if(athread[j].getName().equals("Minecraft main thread")) {
+						instance = (Minecraft)getPrivateValue(Thread.class, athread[j], "target");
+						break;
+					}
+				}
+			} catch (SecurityException var4) {
+				logger.throwing("ModLoader", "getMinecraftInstance", var4);
+				throw new RuntimeException(var4);
+			} catch (NoSuchFieldException var5) {
+				logger.throwing("ModLoader", "getMinecraftInstance", var5);
+				throw new RuntimeException(var5);
+			}
+		}
+
+		return instance;
+	}
+
+	public static Object getPrivateValue(Class class1, Object obj, int i) throws IllegalArgumentException, SecurityException, NoSuchFieldException {
+		try {
+			Field illegalaccessexception = class1.getDeclaredFields()[i];
+			illegalaccessexception.setAccessible(true);
+			return illegalaccessexception.get(obj);
+		} catch (IllegalAccessException var4) {
+			logger.throwing("ModLoader", "getPrivateValue", var4);
+			ThrowException("An impossible error has occured!", var4);
+			return null;
+		}
+	}
+
+	public static Object getPrivateValue(Class class1, Object obj, String s) throws IllegalArgumentException, SecurityException, NoSuchFieldException {
+		try {
+			Field illegalaccessexception = class1.getDeclaredField(s);
+			illegalaccessexception.setAccessible(true);
+			return illegalaccessexception.get(obj);
+		} catch (IllegalAccessException var4) {
+			logger.throwing("ModLoader", "getPrivateValue", var4);
+			ThrowException("An impossible error has occured!", var4);
+			return null;
+		}
+	}
+
+	public static int getUniqueBlockModelID(BaseMod basemod, boolean flag) {
+		int i = nextBlockModelID++;
+		blockModels.put(Integer.valueOf(i), basemod);
+		blockSpecialInv.put(Integer.valueOf(i), Boolean.valueOf(flag));
+		return i;
+	}
+
+	public static int getUniqueEntityId() {
+		return highestEntityId++;
+	}
+
+	private static int getUniqueItemSpriteIndex() {
+		while(itemSpriteIndex < usedItemSprites.length) {
+			if(!usedItemSprites[itemSpriteIndex]) {
+				usedItemSprites[itemSpriteIndex] = true;
+				--itemSpritesLeft;
+				return itemSpriteIndex++;
+			}
+
+			++itemSpriteIndex;
+		}
+
+		Exception exception = new Exception("No more empty item sprite indices left!");
+		logger.throwing("ModLoader", "getUniqueItemSpriteIndex", exception);
+		ThrowException(exception);
+		return 0;
+	}
+
+	public static int getUniqueSpriteIndex(String s) {
+		if(s.equals("/gui/items.png")) {
+			return getUniqueItemSpriteIndex();
+		} else if(s.equals("/terrain.png")) {
+			return getUniqueTerrainSpriteIndex();
+		} else {
+			Exception exception = new Exception("No registry for this texture: " + s);
+			logger.throwing("ModLoader", "getUniqueItemSpriteIndex", exception);
+			ThrowException(exception);
+			return 0;
+		}
+	}
+
+	private static int getUniqueTerrainSpriteIndex() {
+		while(terrainSpriteIndex < usedTerrainSprites.length) {
+			if(!usedTerrainSprites[terrainSpriteIndex]) {
+				usedTerrainSprites[terrainSpriteIndex] = true;
+				--terrainSpritesLeft;
+				return terrainSpriteIndex++;
+			}
+
+			++terrainSpriteIndex;
+		}
+
+		Exception exception = new Exception("No more empty terrain sprite indices left!");
+		logger.throwing("ModLoader", "getUniqueItemSpriteIndex", exception);
+		ThrowException(exception);
+		return 0;
+	}
+
+	private static void init() {
+		hasInit = true;
+		String s = "1111111111111111111111111111111111111101111111011111111111111001111111111111111111111111111011111111100110000011111110000000001111111001100000110000000100000011000000010000001100000000000000110000000000000000000000000000000000000000000000001100000000000000";
+		String s1 = "1111111111111111111111111111110111111111111111111111110111111111111111111111000111111011111111111111001111111110111111111111100011111111000010001111011110000000111111000000000011111100000000001111000000000111111000000000001101000000000001111111111111000011";
+
+		for(int throwable = 0; throwable < 256; ++throwable) {
+			usedItemSprites[throwable] = s.charAt(throwable) == 49;
+			if(!usedItemSprites[throwable]) {
+				++itemSpritesLeft;
+			}
+
+			usedTerrainSprites[throwable] = s1.charAt(throwable) == 49;
+			if(!usedTerrainSprites[throwable]) {
+				++terrainSpritesLeft;
+			}
+		}
+
+		try {
+			instance = (Minecraft)getPrivateValue(Minecraft.class, (Object)null, 1);
+			instance.entityRenderer = new EntityRendererProxy(instance);
+			classMap = (Map)getPrivateValue(EntityList.class, (Object)null, 0);
+			field_modifiers = Field.class.getDeclaredField("modifiers");
+			field_modifiers.setAccessible(true);
+			field_blockList = Session.class.getDeclaredFields()[0];
+			field_blockList.setAccessible(true);
+			field_TileEntityRenderers = TileEntityRenderer.class.getDeclaredFields()[0];
+			field_TileEntityRenderers.setAccessible(true);
+			field_armorList = RenderPlayer.class.getDeclaredFields()[3];
+			field_modifiers.setInt(field_armorList, field_armorList.getModifiers() & -17);
+			field_armorList.setAccessible(true);
+			field_animList = RenderEngine.class.getDeclaredFields()[6];
+			field_animList.setAccessible(true);
+			Field[] var16 = BiomeGenBase.class.getDeclaredFields();
+			LinkedList iterator = new LinkedList();
+
+			for(int basemod = 0; basemod < var16.length; ++basemod) {
+				Class class1 = var16[basemod].getType();
+				if((var16[basemod].getModifiers() & 8) != 0 && class1.isAssignableFrom(BiomeGenBase.class)) {
+					BiomeGenBase biomegenbase = (BiomeGenBase)var16[basemod].get((Object)null);
+					if(!(biomegenbase instanceof BiomeGenHell) && !(biomegenbase instanceof BiomeGenSky)) {
+						iterator.add(biomegenbase);
+					}
+				}
+			}
+
+			standardBiomes = (BiomeGenBase[])((BiomeGenBase[])iterator.toArray(new BiomeGenBase[0]));
+
+			try {
+				method_RegisterTileEntity = TileEntity.class.getDeclaredMethod("a", new Class[]{Class.class, String.class});
+			} catch (NoSuchMethodException var8) {
+				method_RegisterTileEntity = TileEntity.class.getDeclaredMethod("addMapping", new Class[]{Class.class, String.class});
+			}
+
+			method_RegisterTileEntity.setAccessible(true);
+
+			try {
+				method_RegisterEntityID = EntityList.class.getDeclaredMethod("a", new Class[]{Class.class, String.class, Integer.TYPE});
+			} catch (NoSuchMethodException var7) {
+				method_RegisterEntityID = EntityList.class.getDeclaredMethod("addMapping", new Class[]{Class.class, String.class, Integer.TYPE});
+			}
+
+			method_RegisterEntityID.setAccessible(true);
+		} catch (SecurityException var11) {
+			logger.throwing("ModLoader", "init", var11);
+			ThrowException(var11);
+			throw new RuntimeException(var11);
+		} catch (NoSuchFieldException var12) {
+			logger.throwing("ModLoader", "init", var12);
+			ThrowException(var12);
+			throw new RuntimeException(var12);
+		} catch (NoSuchMethodException var13) {
+			logger.throwing("ModLoader", "init", var13);
+			ThrowException(var13);
+			throw new RuntimeException(var13);
+		} catch (IllegalArgumentException var14) {
+			logger.throwing("ModLoader", "init", var14);
+			ThrowException(var14);
+			throw new RuntimeException(var14);
+		} catch (IllegalAccessException var15) {
+			logger.throwing("ModLoader", "init", var15);
+			ThrowException(var15);
+			throw new RuntimeException(var15);
+		}
+
+		try {
+			loadConfig();
+			if(props.containsKey("loggingLevel")) {
+				cfgLoggingLevel = Level.parse(props.getProperty("loggingLevel"));
+			}
+
+			if(props.containsKey("grassFix")) {
+				RenderBlocks.fancyGrass = Boolean.parseBoolean(props.getProperty("grassFix"));
+			}
+
+			logger.setLevel(cfgLoggingLevel);
+			if((logfile.exists() || logfile.createNewFile()) && logfile.canWrite() && logHandler == null) {
+				logHandler = new FileHandler(logfile.getPath());
+				logHandler.setFormatter(new SimpleFormatter());
+				logger.addHandler(logHandler);
+			}
+
+			logger.fine("ModLoader Beta 1.7.3 Initializing...");
+			System.out.println("ModLoader Beta 1.7.3 Initializing...");
+			System.out.println("***** Modloader Fix by coffeenotfound @ 2017 ~ https://github.com/coffeenotfound ~ https://bitangent.net/ ****");
+
+			File var17;
+			try {
+				String var18 = URLDecoder.decode(ModLoader.class.getProtectionDomain().getCodeSource().getLocation().getPath(), "UTF-8");
+				var18 = var18.replace("jar:", "").replace("file:/", "").replace("file:\\", "");
+				if(var18.contains(".jar!")) {
+					var18 = var18.substring(0, var18.lastIndexOf(".jar!") + ".jar".length());
+				}
+
+				var18 = (new File(var18)).getAbsolutePath();
+				System.out.println("[Modloader Fix] original jar path = " + ModLoader.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath());
+				System.out.println("[Modloader Fix] new jar path = " + var18);
+				var17 = new File(var18);
+			} catch (Exception var9) {
+				throw new RuntimeException("Failed to resolve minecraft jar path; this is the fixed code, if this exception ever gets thrown I owe you a beer.", var9);
+			}
+
+			modDir.mkdirs();
+			readFromModFolder(modDir);
+			readFromClassPath(var17);
+			System.out.println("Done.");
+			props.setProperty("loggingLevel", cfgLoggingLevel.getName());
+			props.setProperty("grassFix", Boolean.toString(RenderBlocks.fancyGrass));
+			Iterator var20 = modList.iterator();
+
+			while(var20.hasNext()) {
+				BaseMod var19 = (BaseMod)var20.next();
+				var19.ModsLoaded();
+				if(!props.containsKey(var19.getClass().getName())) {
+					props.setProperty(var19.getClass().getName(), "on");
+				}
+			}
+
+			instance.gameSettings.keyBindings = RegisterAllKeys(instance.gameSettings.keyBindings);
+			instance.gameSettings.loadOptions();
+			initStats();
+			saveConfig();
+		} catch (Throwable var10) {
+			logger.throwing("ModLoader", "init", var10);
+			ThrowException("ModLoader has failed to initialize.", var10);
+			if(logHandler != null) {
+				logHandler.close();
+			}
+
+			throw new RuntimeException(var10);
+		}
+	}
+
+	private static void initStats() {
+		int hashset;
+		String obj;
+		for(hashset = 0; hashset < Block.blocksList.length; ++hashset) {
+			if(!StatList.field_25169_C.containsKey(Integer.valueOf(16777216 + hashset)) && Block.blocksList[hashset] != null && Block.blocksList[hashset].getEnableStats()) {
+				obj = StringTranslate.getInstance().translateKeyFormat("stat.mineBlock", new Object[]{Block.blocksList[hashset].translateBlockName()});
+				StatList.mineBlockStatArray[hashset] = (new StatCrafting(16777216 + hashset, obj, hashset)).registerStat();
+				StatList.field_25185_d.add(StatList.mineBlockStatArray[hashset]);
+			}
+		}
+
+		for(hashset = 0; hashset < Item.itemsList.length; ++hashset) {
+			if(!StatList.field_25169_C.containsKey(Integer.valueOf(16908288 + hashset)) && Item.itemsList[hashset] != null) {
+				obj = StringTranslate.getInstance().translateKeyFormat("stat.useItem", new Object[]{Item.itemsList[hashset].getStatName()});
+				StatList.field_25172_A[hashset] = (new StatCrafting(16908288 + hashset, obj, hashset)).registerStat();
+				if(hashset >= Block.blocksList.length) {
+					StatList.field_25186_c.add(StatList.field_25172_A[hashset]);
+				}
+			}
+
+			if(!StatList.field_25169_C.containsKey(Integer.valueOf(16973824 + hashset)) && Item.itemsList[hashset] != null && Item.itemsList[hashset].isDamagable()) {
+				obj = StringTranslate.getInstance().translateKeyFormat("stat.breakItem", new Object[]{Item.itemsList[hashset].getStatName()});
+				StatList.field_25170_B[hashset] = (new StatCrafting(16973824 + hashset, obj, hashset)).registerStat();
+			}
+		}
+
+		HashSet var6 = new HashSet();
+		Iterator obj1 = CraftingManager.getInstance().getRecipeList().iterator();
+
+		while(obj1.hasNext()) {
+			Object var7 = obj1.next();
+			var6.add(Integer.valueOf(((IRecipe)var7).getRecipeOutput().itemID));
+		}
+
+		Iterator iterator2 = FurnaceRecipes.smelting().getSmeltingList().values().iterator();
+
+		while(iterator2.hasNext()) {
+			Object var8 = iterator2.next();
+			var6.add(Integer.valueOf(((ItemStack)var8).itemID));
+		}
+
+		iterator2 = var6.iterator();
+
+		while(iterator2.hasNext()) {
+			int k = ((Integer)iterator2.next()).intValue();
+			if(!StatList.field_25169_C.containsKey(Integer.valueOf(16842752 + k)) && Item.itemsList[k] != null) {
+				String s3 = StringTranslate.getInstance().translateKeyFormat("stat.craftItem", new Object[]{Item.itemsList[k].getStatName()});
+				StatList.field_25158_z[k] = (new StatCrafting(16842752 + k, s3, k)).registerStat();
+			}
+		}
+
+	}
+
+	public static boolean isGUIOpen(Class class1) {
+		Minecraft minecraft = getMinecraftInstance();
+		return class1 == null ? minecraft.currentScreen == null : (minecraft.currentScreen == null && class1 != null ? false : class1.isInstance(minecraft.currentScreen));
+	}
+
+	public static boolean isModLoaded(String s) {
+		Class class1 = null;
+
+		try {
+			class1 = Class.forName(s);
+		} catch (ClassNotFoundException var4) {
+			return false;
+		}
+
+		if(class1 != null) {
+			Iterator iterator = modList.iterator();
+
+			while(iterator.hasNext()) {
+				BaseMod basemod = (BaseMod)iterator.next();
+				if(class1.isInstance(basemod)) {
+					return true;
+				}
+			}
+		}
+
+		return false;
+	}
+
+	public static void loadConfig() throws IOException {
+		cfgdir.mkdir();
+		if(cfgfile.exists() || cfgfile.createNewFile()) {
+			if(cfgfile.canRead()) {
+				FileInputStream fileinputstream = new FileInputStream(cfgfile);
+				props.load(fileinputstream);
+				fileinputstream.close();
+			}
+
+		}
+	}
+
+	public static BufferedImage loadImage(RenderEngine renderengine, String s) throws Exception {
+		TexturePackList texturepacklist = (TexturePackList)getPrivateValue(RenderEngine.class, renderengine, 11);
+		InputStream inputstream = texturepacklist.selectedTexturePack.getResourceAsStream(s);
+		if(inputstream == null) {
+			throw new Exception("Image not found: " + s);
+		} else {
+			BufferedImage bufferedimage = ImageIO.read(inputstream);
+			if(bufferedimage == null) {
+				throw new Exception("Image corrupted: " + s);
+			} else {
+				return bufferedimage;
+			}
+		}
+	}
+
+	public static void OnItemPickup(EntityPlayer entityplayer, ItemStack itemstack) {
+		Iterator iterator = modList.iterator();
+
+		while(iterator.hasNext()) {
+			BaseMod basemod = (BaseMod)iterator.next();
+			basemod.OnItemPickup(entityplayer, itemstack);
+		}
+
+	}
+
+	public static void OnTick(Minecraft minecraft) {
+		if(!hasInit) {
+			init();
+			logger.fine("Initialized");
+		}
+
+		if(texPack == null || minecraft.gameSettings.skin != texPack) {
+			texturesAdded = false;
+			texPack = minecraft.gameSettings.skin;
+		}
+
+		if(!texturesAdded && minecraft.renderEngine != null) {
+			RegisterAllTextureOverrides(minecraft.renderEngine);
+			texturesAdded = true;
+		}
+
+		long l = 0L;
+		Iterator iterator2;
+		Entry entry;
+		if(minecraft.theWorld != null) {
+			l = minecraft.theWorld.getWorldTime();
+			iterator2 = inGameHooks.entrySet().iterator();
+
+			label94:
+			while(true) {
+				do {
+					if(!iterator2.hasNext()) {
+						break label94;
+					}
+
+					entry = (Entry)iterator2.next();
+				} while(clock == l && ((Boolean)entry.getValue()).booleanValue());
+
+				if(!((BaseMod)entry.getKey()).OnTickInGame(minecraft)) {
+					iterator2.remove();
+				}
+			}
+		}
+
+		if(minecraft.currentScreen != null) {
+			iterator2 = inGUIHooks.entrySet().iterator();
+
+			label81:
+			while(true) {
+				do {
+					if(!iterator2.hasNext()) {
+						break label81;
+					}
+
+					entry = (Entry)iterator2.next();
+				} while(clock == l && ((Boolean)entry.getValue()).booleanValue() & minecraft.theWorld != null);
+
+				if(!((BaseMod)entry.getKey()).OnTickInGUI(minecraft, minecraft.currentScreen)) {
+					iterator2.remove();
+				}
+			}
+		}
+
+		if(clock != l) {
+			iterator2 = keyList.entrySet().iterator();
+
+			label67:
+			while(iterator2.hasNext()) {
+				entry = (Entry)iterator2.next();
+				Iterator iterator3 = ((Map)entry.getValue()).entrySet().iterator();
+
+				while(true) {
+					Entry entry3;
+					boolean flag;
+					boolean[] aflag;
+					boolean flag1;
+					do {
+						do {
+							if(!iterator3.hasNext()) {
+								continue label67;
+							}
+
+							entry3 = (Entry)iterator3.next();
+							flag = Keyboard.isKeyDown(((KeyBinding)entry3.getKey()).keyCode);
+							aflag = (boolean[])((boolean[])entry3.getValue());
+							flag1 = aflag[1];
+							aflag[1] = flag;
+						} while(!flag);
+					} while(flag1 && !aflag[0]);
+
+					((BaseMod)entry.getKey()).KeyboardEvent((KeyBinding)entry3.getKey());
+				}
+			}
+		}
+
+		clock = l;
+	}
+
+	public static void OpenGUI(EntityPlayer entityplayer, GuiScreen guiscreen) {
+		if(!hasInit) {
+			init();
+			logger.fine("Initialized");
+		}
+
+		Minecraft minecraft = getMinecraftInstance();
+		if(minecraft.thePlayer == entityplayer) {
+			if(guiscreen != null) {
+				minecraft.displayGuiScreen(guiscreen);
+			}
+
+		}
+	}
+
+	public static void PopulateChunk(IChunkProvider ichunkprovider, int i, int j, World world) {
+		if(!hasInit) {
+			init();
+			logger.fine("Initialized");
+		}
+
+		Random random = new Random(world.getRandomSeed());
+		long l = random.nextLong() / 2L * 2L + 1L;
+		long l1 = random.nextLong() / 2L * 2L + 1L;
+		random.setSeed((long)i * l + (long)j * l1 ^ world.getRandomSeed());
+		Iterator iterator = modList.iterator();
+
+		while(iterator.hasNext()) {
+			BaseMod basemod = (BaseMod)iterator.next();
+			if(ichunkprovider.makeString().equals("RandomLevelSource")) {
+				basemod.GenerateSurface(world, random, i << 4, j << 4);
+			} else if(ichunkprovider.makeString().equals("HellRandomLevelSource")) {
+				basemod.GenerateNether(world, random, i << 4, j << 4);
+			}
+		}
+
+	}
+
+	private static void readFromClassPath(File file) throws FileNotFoundException, IOException {
+		logger.finer("Adding mods from " + file.getCanonicalPath());
+		ClassLoader classloader = ModLoader.class.getClassLoader();
+		if(file.isFile() && (file.getName().endsWith(".jar") || file.getName().endsWith(".zip"))) {
+			logger.finer("Zip found.");
+			FileInputStream var7 = new FileInputStream(file);
+			ZipInputStream var9 = new ZipInputStream(var7);
+			Object var10 = null;
+
+			while(true) {
+				ZipEntry var11 = var9.getNextEntry();
+				if(var11 == null) {
+					var7.close();
+					break;
+				}
+
+				String s1 = var11.getName();
+				if(!var11.isDirectory() && s1.startsWith("mod_") && s1.endsWith(".class")) {
+					addMod(classloader, s1);
+				}
+			}
+		} else if(file.isDirectory()) {
+			Package package1 = ModLoader.class.getPackage();
+			if(package1 != null) {
+				String afile = package1.getName().replace('.', File.separatorChar);
+				file = new File(file, afile);
+			}
+
+			logger.finer("Directory found.");
+			File[] var8 = file.listFiles();
+			if(var8 != null) {
+				for(int i = 0; i < var8.length; ++i) {
+					String s2 = var8[i].getName();
+					if(var8[i].isFile() && s2.startsWith("mod_") && s2.endsWith(".class")) {
+						addMod(classloader, s2);
+					}
+				}
+			}
+		}
+
+	}
+
+	private static void readFromModFolder(File file) throws IOException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, SecurityException, NoSuchMethodException {
+		ClassLoader classloader = Minecraft.class.getClassLoader();
+		Method method = URLClassLoader.class.getDeclaredMethod("addURL", new Class[]{URL.class});
+		method.setAccessible(true);
+		if(!file.isDirectory()) {
+			throw new IllegalArgumentException("folder must be a Directory.");
+		} else {
+			File[] afile = file.listFiles();
+			int j;
+			File file2;
+			if(classloader instanceof URLClassLoader) {
+				for(j = 0; j < afile.length; ++j) {
+					file2 = afile[j];
+					if(file2.isDirectory() || file2.isFile() && (file2.getName().endsWith(".jar") || file2.getName().endsWith(".zip"))) {
+						method.invoke(classloader, new Object[]{file2.toURI().toURL()});
+					}
+				}
+			}
+
+			for(j = 0; j < afile.length; ++j) {
+				file2 = afile[j];
+				if(file2.isDirectory() || file2.isFile() && (file2.getName().endsWith(".jar") || file2.getName().endsWith(".zip"))) {
+					logger.finer("Adding mods from " + file2.getCanonicalPath());
+					if(!file2.isFile()) {
+						if(file2.isDirectory()) {
+							Package var11 = ModLoader.class.getPackage();
+							if(var11 != null) {
+								String var12 = var11.getName().replace('.', File.separatorChar);
+								file2 = new File(file2, var12);
+							}
+
+							logger.finer("Directory found.");
+							File[] var13 = file2.listFiles();
+							if(var13 != null) {
+								for(int var14 = 0; var14 < var13.length; ++var14) {
+									String var15 = var13[var14].getName();
+									if(var13[var14].isFile() && var15.startsWith("mod_") && var15.endsWith(".class")) {
+										addMod(classloader, var15);
+									}
+								}
+							}
+						}
+					} else {
+						logger.finer("Zip found.");
+						FileInputStream package1 = new FileInputStream(file2);
+						ZipInputStream afile1 = new ZipInputStream(package1);
+						Object k = null;
+
+						while(true) {
+							ZipEntry s2 = afile1.getNextEntry();
+							if(s2 == null) {
+								afile1.close();
+								package1.close();
+								break;
+							}
+
+							String s1 = s2.getName();
+							if(!s2.isDirectory() && s1.startsWith("mod_") && s1.endsWith(".class")) {
+								addMod(classloader, s1);
+							}
+						}
+					}
+				}
+			}
+
+		}
+	}
+
+	public static KeyBinding[] RegisterAllKeys(KeyBinding[] akeybinding) {
+		LinkedList linkedlist = new LinkedList();
+		linkedlist.addAll(Arrays.asList(akeybinding));
+		Iterator iterator = keyList.values().iterator();
+
+		while(iterator.hasNext()) {
+			Map map = (Map)iterator.next();
+			linkedlist.addAll(map.keySet());
+		}
+
+		return (KeyBinding[])((KeyBinding[])linkedlist.toArray(new KeyBinding[0]));
+	}
+
+	public static void RegisterAllTextureOverrides(RenderEngine renderengine) {
+		animList.clear();
+		Minecraft minecraft = getMinecraftInstance();
+		Iterator texturefx = modList.iterator();
+
+		while(texturefx.hasNext()) {
+			BaseMod basemod = (BaseMod)texturefx.next();
+			basemod.RegisterAnimation(minecraft);
+		}
+
+		Iterator iterator2 = animList.iterator();
+
+		while(iterator2.hasNext()) {
+			TextureFX texturefx1 = (TextureFX)iterator2.next();
+			renderengine.registerTextureFX(texturefx1);
+		}
+
+		iterator2 = overrides.entrySet().iterator();
+
+		while(iterator2.hasNext()) {
+			Entry entry = (Entry)iterator2.next();
+			Iterator iterator3 = ((Map)entry.getValue()).entrySet().iterator();
+
+			while(iterator3.hasNext()) {
+				Entry entry1 = (Entry)iterator3.next();
+				String s = (String)entry1.getKey();
+				int i = ((Integer)entry1.getValue()).intValue();
+				int j = ((Integer)entry.getKey()).intValue();
+
+				try {
+					BufferedImage exception = loadImage(renderengine, s);
+					ModTextureStatic modtexturestatic = new ModTextureStatic(i, j, exception);
+					renderengine.registerTextureFX(modtexturestatic);
+				} catch (Exception var13) {
+					logger.throwing("ModLoader", "RegisterAllTextureOverrides", var13);
+					ThrowException(var13);
+					throw new RuntimeException(var13);
+				}
+			}
+		}
+
+	}
+
+	public static void RegisterBlock(Block block) {
+		RegisterBlock(block, (Class)null);
+	}
+
+	public static void RegisterBlock(Block block, Class class1) {
+		try {
+			if(block == null) {
+				throw new IllegalArgumentException("block parameter cannot be null.");
+			}
+
+			List nosuchmethodexception = (List)field_blockList.get((Object)null);
+			nosuchmethodexception.add(block);
+			int i = block.blockID;
+			ItemBlock itemblock = null;
+			if(class1 != null) {
+				itemblock = (ItemBlock)class1.getConstructor(new Class[]{Integer.TYPE}).newInstance(new Object[]{Integer.valueOf(i - 256)});
+			} else {
+				itemblock = new ItemBlock(i - 256);
+			}
+
+			if(Block.blocksList[i] != null && Item.itemsList[i] == null) {
+				Item.itemsList[i] = itemblock;
+			}
+		} catch (IllegalArgumentException var5) {
+			logger.throwing("ModLoader", "RegisterBlock", var5);
+			ThrowException(var5);
+		} catch (IllegalAccessException var6) {
+			logger.throwing("ModLoader", "RegisterBlock", var6);
+			ThrowException(var6);
+		} catch (SecurityException var7) {
+			logger.throwing("ModLoader", "RegisterBlock", var7);
+			ThrowException(var7);
+		} catch (InstantiationException var8) {
+			logger.throwing("ModLoader", "RegisterBlock", var8);
+			ThrowException(var8);
+		} catch (InvocationTargetException var9) {
+			logger.throwing("ModLoader", "RegisterBlock", var9);
+			ThrowException(var9);
+		} catch (NoSuchMethodException var10) {
+			logger.throwing("ModLoader", "RegisterBlock", var10);
+			ThrowException(var10);
+		}
+
+	}
+
+	public static void RegisterEntityID(Class class1, String s, int i) {
+		try {
+			method_RegisterEntityID.invoke((Object)null, new Object[]{class1, s, Integer.valueOf(i)});
+		} catch (IllegalArgumentException var4) {
+			logger.throwing("ModLoader", "RegisterEntityID", var4);
+			ThrowException(var4);
+		} catch (IllegalAccessException var5) {
+			logger.throwing("ModLoader", "RegisterEntityID", var5);
+			ThrowException(var5);
+		} catch (InvocationTargetException var6) {
+			logger.throwing("ModLoader", "RegisterEntityID", var6);
+			ThrowException(var6);
+		}
+
+	}
+
+	public static void RegisterKey(BaseMod basemod, KeyBinding keybinding, boolean flag) {
+		Object obj = (Map)keyList.get(basemod);
+		if(obj == null) {
+			obj = new HashMap();
+		}
+
+		boolean[] aflag = new boolean[]{flag, false};
+		((Map)((Map)obj)).put(keybinding, aflag);
+		keyList.put(basemod, obj);
+	}
+
+	public static void RegisterTileEntity(Class class1, String s) {
+		RegisterTileEntity(class1, s, (TileEntitySpecialRenderer)null);
+	}
+
+	public static void RegisterTileEntity(Class class1, String s, TileEntitySpecialRenderer tileentityspecialrenderer) {
+		try {
+			method_RegisterTileEntity.invoke((Object)null, new Object[]{class1, s});
+			if(tileentityspecialrenderer != null) {
+				TileEntityRenderer invocationtargetexception = TileEntityRenderer.instance;
+				Map map = (Map)field_TileEntityRenderers.get(invocationtargetexception);
+				map.put(class1, tileentityspecialrenderer);
+				tileentityspecialrenderer.setTileEntityRenderer(invocationtargetexception);
+			}
+		} catch (IllegalArgumentException var5) {
+			logger.throwing("ModLoader", "RegisterTileEntity", var5);
+			ThrowException(var5);
+		} catch (IllegalAccessException var6) {
+			logger.throwing("ModLoader", "RegisterTileEntity", var6);
+			ThrowException(var6);
+		} catch (InvocationTargetException var7) {
+			logger.throwing("ModLoader", "RegisterTileEntity", var7);
+			ThrowException(var7);
+		}
+
+	}
+
+	public static void RemoveSpawn(Class class1, EnumCreatureType enumcreaturetype) {
+		RemoveSpawn((Class)class1, enumcreaturetype, (BiomeGenBase[])null);
+	}
+
+	public static void RemoveSpawn(Class class1, EnumCreatureType enumcreaturetype, BiomeGenBase[] abiomegenbase) {
+		if(class1 == null) {
+			throw new IllegalArgumentException("entityClass cannot be null");
+		} else if(enumcreaturetype == null) {
+			throw new IllegalArgumentException("spawnList cannot be null");
+		} else {
+			if(abiomegenbase == null) {
+				abiomegenbase = standardBiomes;
+			}
+
+			for(int i = 0; i < abiomegenbase.length; ++i) {
+				List list = abiomegenbase[i].getSpawnableList(enumcreaturetype);
+				if(list != null) {
+					Iterator iterator = list.iterator();
+
+					while(iterator.hasNext()) {
+						SpawnListEntry spawnlistentry = (SpawnListEntry)iterator.next();
+						if(spawnlistentry.entityClass == class1) {
+							iterator.remove();
+						}
+					}
+				}
+			}
+
+		}
+	}
+
+	public static void RemoveSpawn(String s, EnumCreatureType enumcreaturetype) {
+		RemoveSpawn((String)s, enumcreaturetype, (BiomeGenBase[])null);
+	}
+
+	public static void RemoveSpawn(String s, EnumCreatureType enumcreaturetype, BiomeGenBase[] abiomegenbase) {
+		Class class1 = (Class)classMap.get(s);
+		if(class1 != null && EntityLiving.class.isAssignableFrom(class1)) {
+			RemoveSpawn(class1, enumcreaturetype, abiomegenbase);
+		}
+
+	}
+
+	public static boolean RenderBlockIsItemFull3D(int i) {
+		return !blockSpecialInv.containsKey(Integer.valueOf(i)) ? i == 16 : ((Boolean)blockSpecialInv.get(Integer.valueOf(i))).booleanValue();
+	}
+
+	public static void RenderInvBlock(RenderBlocks renderblocks, Block block, int i, int j) {
+		BaseMod basemod = (BaseMod)blockModels.get(Integer.valueOf(j));
+		if(basemod != null) {
+			basemod.RenderInvBlock(renderblocks, block, i, j);
+		}
+	}
+
+	public static boolean RenderWorldBlock(RenderBlocks renderblocks, IBlockAccess iblockaccess, int i, int j, int k, Block block, int l) {
+		BaseMod basemod = (BaseMod)blockModels.get(Integer.valueOf(l));
+		return basemod == null ? false : basemod.RenderWorldBlock(renderblocks, iblockaccess, i, j, k, block, l);
+	}
+
+	public static void saveConfig() throws IOException {
+		cfgdir.mkdir();
+		if(cfgfile.exists() || cfgfile.createNewFile()) {
+			if(cfgfile.canWrite()) {
+				FileOutputStream fileoutputstream = new FileOutputStream(cfgfile);
+				props.store(fileoutputstream, "ModLoader Config");
+				fileoutputstream.close();
+			}
+
+		}
+	}
+
+	public static void SetInGameHook(BaseMod basemod, boolean flag, boolean flag1) {
+		if(flag) {
+			inGameHooks.put(basemod, Boolean.valueOf(flag1));
+		} else {
+			inGameHooks.remove(basemod);
+		}
+
+	}
+
+	public static void SetInGUIHook(BaseMod basemod, boolean flag, boolean flag1) {
+		if(flag) {
+			inGUIHooks.put(basemod, Boolean.valueOf(flag1));
+		} else {
+			inGUIHooks.remove(basemod);
+		}
+
+	}
+
+	public static void setPrivateValue(Class class1, Object obj, int i, Object obj1) throws IllegalArgumentException, SecurityException, NoSuchFieldException {
+		try {
+			Field illegalaccessexception = class1.getDeclaredFields()[i];
+			illegalaccessexception.setAccessible(true);
+			int j = field_modifiers.getInt(illegalaccessexception);
+			if((j & 16) != 0) {
+				field_modifiers.setInt(illegalaccessexception, j & -17);
+			}
+
+			illegalaccessexception.set(obj, obj1);
+		} catch (IllegalAccessException var6) {
+			logger.throwing("ModLoader", "setPrivateValue", var6);
+			ThrowException("An impossible error has occured!", var6);
+		}
+
+	}
+
+	public static void setPrivateValue(Class class1, Object obj, String s, Object obj1) throws IllegalArgumentException, SecurityException, NoSuchFieldException {
+		try {
+			Field illegalaccessexception = class1.getDeclaredField(s);
+			int i = field_modifiers.getInt(illegalaccessexception);
+			if((i & 16) != 0) {
+				field_modifiers.setInt(illegalaccessexception, i & -17);
+			}
+
+			illegalaccessexception.setAccessible(true);
+			illegalaccessexception.set(obj, obj1);
+		} catch (IllegalAccessException var6) {
+			logger.throwing("ModLoader", "setPrivateValue", var6);
+			ThrowException("An impossible error has occured!", var6);
+		}
+
+	}
+
+	private static void setupProperties(Class class1) throws IllegalArgumentException, IllegalAccessException, IOException, SecurityException, NoSuchFieldException {
+		Properties properties = new Properties();
+		File file = new File(cfgdir, class1.getName() + ".cfg");
+		if(file.exists() && file.canRead()) {
+			properties.load(new FileInputStream(file));
+		}
+
+		StringBuilder stringbuilder = new StringBuilder();
+		Field[] afield = class1.getFields();
+		int j = afield.length;
+
+		for(int i = 0; i < j; ++i) {
+			Field field = afield[i];
+			if((field.getModifiers() & 8) != 0 && field.isAnnotationPresent(MLProp.class)) {
+				Class class2 = field.getType();
+				MLProp mlprop = (MLProp)field.getAnnotation(MLProp.class);
+				String s = mlprop.name().length() != 0 ? mlprop.name() : field.getName();
+				Object obj = field.get((Object)null);
+				StringBuilder stringbuilder1 = new StringBuilder();
+				if(mlprop.min() != -Double.POSITIVE_INFINITY) {
+					stringbuilder1.append(String.format(",>=%.1f", new Object[]{Double.valueOf(mlprop.min())}));
+				}
+
+				if(mlprop.max() != Double.POSITIVE_INFINITY) {
+					stringbuilder1.append(String.format(",<=%.1f", new Object[]{Double.valueOf(mlprop.max())}));
+				}
+
+				StringBuilder stringbuilder2 = new StringBuilder();
+				if(mlprop.info().length() > 0) {
+					stringbuilder2.append(" -- ");
+					stringbuilder2.append(mlprop.info());
+				}
+
+				stringbuilder.append(String.format("%s (%s:%s%s)%s\n", new Object[]{s, class2.getName(), obj, stringbuilder1, stringbuilder2}));
+				if(properties.containsKey(s)) {
+					String s1 = properties.getProperty(s);
+					Object obj1 = null;
+					if(class2.isAssignableFrom(String.class)) {
+						obj1 = s1;
+					} else if(class2.isAssignableFrom(Integer.TYPE)) {
+						obj1 = Integer.valueOf(Integer.parseInt(s1));
+					} else if(class2.isAssignableFrom(Short.TYPE)) {
+						obj1 = Short.valueOf(Short.parseShort(s1));
+					} else if(class2.isAssignableFrom(Byte.TYPE)) {
+						obj1 = Byte.valueOf(Byte.parseByte(s1));
+					} else if(class2.isAssignableFrom(Boolean.TYPE)) {
+						obj1 = Boolean.valueOf(Boolean.parseBoolean(s1));
+					} else if(class2.isAssignableFrom(Float.TYPE)) {
+						obj1 = Float.valueOf(Float.parseFloat(s1));
+					} else if(class2.isAssignableFrom(Double.TYPE)) {
+						obj1 = Double.valueOf(Double.parseDouble(s1));
+					}
+
+					if(obj1 != null) {
+						if(obj1 instanceof Number) {
+							double d = ((Number)obj1).doubleValue();
+							if(mlprop.min() != -Double.POSITIVE_INFINITY && d < mlprop.min() || mlprop.max() != Double.POSITIVE_INFINITY && d > mlprop.max()) {
+								continue;
+							}
+						}
+
+						logger.finer(s + " set to " + obj1);
+						if(!obj1.equals(obj)) {
+							field.set((Object)null, obj1);
+						}
+					}
+				} else {
+					logger.finer(s + " not in config, using default: " + obj);
+					properties.setProperty(s, obj.toString());
+				}
+			}
+		}
+
+		if(!properties.isEmpty() && (file.exists() || file.createNewFile()) && file.canWrite()) {
+			properties.store(new FileOutputStream(file), stringbuilder.toString());
+		}
+
+	}
+
+	public static void TakenFromCrafting(EntityPlayer entityplayer, ItemStack itemstack) {
+		Iterator iterator = modList.iterator();
+
+		while(iterator.hasNext()) {
+			BaseMod basemod = (BaseMod)iterator.next();
+			basemod.TakenFromCrafting(entityplayer, itemstack);
+		}
+
+	}
+
+	public static void TakenFromFurnace(EntityPlayer entityplayer, ItemStack itemstack) {
+		Iterator iterator = modList.iterator();
+
+		while(iterator.hasNext()) {
+			BaseMod basemod = (BaseMod)iterator.next();
+			basemod.TakenFromFurnace(entityplayer, itemstack);
+		}
+
+	}
+
+	public static void ThrowException(String s, Throwable throwable) {
+		Minecraft minecraft = getMinecraftInstance();
+		if(minecraft != null) {
+			minecraft.displayUnexpectedThrowable(new UnexpectedThrowable(s, throwable));
+		} else {
+			throw new RuntimeException(throwable);
+		}
+	}
+
+	private static void ThrowException(Throwable throwable) {
+		ThrowException("Exception occured in ModLoader", throwable);
+	}
+}
--- /dev/null
+++ net/minecraft/src/MLProp.java
@@ -1,0 +1,18 @@
+package net.minecraft.src;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.FIELD})
+public @interface MLProp {
+	String name() default "";
+
+	String info() default "";
+
+	double min() default Double.NEGATIVE_INFINITY;
+
+	double max() default Double.POSITIVE_INFINITY;
+}
--- net/minecraft/src/SlotCrafting.java
+++ net/minecraft/src/SlotCrafting.java
@@ -34,6 +34,8 @@
 			this.thePlayer.addStat(AchievementList.buildSword, 1);
 		}
 
+		ModLoader.TakenFromCrafting(this.thePlayer, var1);
+
 		for(int var2 = 0; var2 < this.craftMatrix.getSizeInventory(); ++var2) {
 			ItemStack var3 = this.craftMatrix.getStackInSlot(var2);
 			if(var3 != null) {
